# Порядок работы с файлом readme md(1)

## Что такое git
**Git (/ɡɪt/)** - это программное обеспечение для отслеживания изменений в любом наборе файлов, обычно используемое для координации работы программистов, совместно разрабатывающих исходный код во время разработки программного обеспечения.

## Подготовка репозитория
Обычно вы получаете репозиторий Git одним из двух способов:

1. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git.
2. Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

Создание репозитория в существующем каталоге
Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:

![](img1.png)

Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе ваш проект ещё не находится под версионным контролем. 

Для этого надо применить эту команду в той папке, где в будущем будет репозиторий.

## Создание сохранений
 
Метод сохранения файла или набора файлов в git сильно отличается от процесса в редакторе файлов. Для сохранения последних версий файла используют следующие команды:
1. **git status**
2. **git add**
3. **git commit**

**Git status** - как следует из названия, эта команда отображает состояние рабочей области и промежуточной области.Он отображает пути в рабочем каталоге и перечисляет файлы, которые отслеживаются или не отслеживаются. Эта команда очень полезна, поскольку она позволяет пользователю знать, что он делает, прежде чем вносить изменения, которые он не хочет.

**Git add** - это команда-информатор.Он действует как промежуточное звено между пользователем и git. Он информирует git о том, что изменения должны быть включены на следующем этапе.Это не влияет на репозиторий до тех пор, пока не будет вызвана команда git commit. Команда применяется следующим образом **git add имя_файла**. 

**Git commit** - эта команда фиксирует изменения. Наряду с git add является одной из наиболее часто используемых команд.
Ниже приведены некоторые важные параметры команды git commit:

**-a**
Он включает в себя все измененные в данный момент файлы в этом коммите, но новые неотслеживаемые файлы не затрагиваются.

**-m** "message"
Это создает команду фиксации с отображаемым сообщением.Эта команда по умолчанию открывает локально настроенный текстовый редактор. Сообщения к коммиту писать ОБЯЗАТЕЛЬНО!

**-am** 
Это команда быстрого доступа, которая объединяет опции -a и -m.

**–change**
Эта опция позволяет пользователю изменять последний коммит. Если пользователь не укажет сообщение о фиксации с помощью -m, по умолчанию ему будет предложено ввести сообщение предыдущей команды фиксации. Эта команда не создает новый коммит, а завершает последний.


Для того, чтобы посмотреть разницу между последним коммитом и текущей версией файлов, используется команда **git diff**. Достаточно её просто применить в папке с репозиторием.


## Перемещения между сохранениями

Для того, чтобы перемещаться между сохранениями необходимо использовать команду **git checkout**. 

Применяется она следующим образом в папке с репозиторием: **git checkout номер_коммита**.
Можно отменить изменения с помощью команд **git revert** и **git reset**: 
* **git revert номер_коммита** - отменит изменения до указанной версии и создаст новый коммит. 
* **git reset --hard номер_коммита** - отменит изменения до указанного коммита и затрёт всю историю изменений после этого коммита.

## Журнал изменений

Журнал изменений — это файл, который содержит общий, хронологически упорядоченный список изменений, внесенных в проект. Он часто организован по версии с указанием даты, после чего следует список добавленных, переработанных и удаленных функций. Просмотреть историю изменений можно с помощью команды **git log**. 

**git log -graph** позволяет вывести список коммитов в виде красивого графа/дерева.

## Ветки в git
Ветвление стало неотъемлемой частью командной разработки, потому что оно дает возможность работать над разными версиями исходного кода. Основной идеей ветвления является отклонение от основного кода и продолжение работы независимо от него. Также это удобно в тестировании отдельного функционала, потому что позволяет работать над новой частью кода, не беспокоясь о поломке чего-то в рабочей версии.

Под веткой принято понимать независимую последовательность коммитов в хронологическом порядке. Однако конкретно в Git реализация ветки выполнена как указатель на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.

Имя основной ветки Git-проекта по умолчанию — master (однако зачастую бывает main, например, в GitHub), она появляется сразу при инициализации репозитория. Эта ветка ничем не отличается от остальных и также ее можно переименовать, но по договоренности master принято считать главной веткой в проекте.

Команда git branch — главный инструмент для работы с ветвлением. С ее помощью можно добавлять новые ветки, перечислять и переименовывать существующие и удалять их.

Для того, чтобы просмотреть список имеющихся веток, необходимо использовать команду **git branch**. 

Для того, чтобы создать новую ветку, необходимо использовать команду **git branch имя_новой_ветки**. 

Для того чтобы удалить ветку необходимо использовать команду **git branch --d имя_ветки**. Параметр --d означает delete - удалять.


## Слияние веток и решение конфликтов
Ветка – независимая последовательность коммитов. Ветки нужны, чтобы тестировать новые функции и распараллеливать работу над проектом.
Первоначально мы работаем в основной ветке. У нас она называется master. 

Обычно в основной ветке находится та же версия кода, что и в продакшене. То есть если в основную ветку попадут какие-то непроверенные изменения, код может сломаться и повлечь за собой поломку приложения у конечного пользователя. Поэтому во всех командах, работающих над серьезными проектами, принято, что в основной ветке находятся только протестированные изменения, которые в идеале не придется экстренно исправлять.

То есть общий ход нашей работы выглядит следующим образом:
1. Решили добавить новую функцию – создали отдельную ветку. Дальше работаем в новой ветке.
2. Написали функцию, протестировали ее работу, внесли все необходимые исправления, еще раз протестировали и убедились, что функция работает исправно и не привнесла ошибок в остальной код.
3. Теперь нужно как-то перенести изменения с тестовой ветки на основную – в продакшн. Тут нам на помощь и приходит слияние: мы просто сливаем (т.е. переносим) изменения с нашей тестовой ветки в основную.

**Сливаемая ветка** – та ветка, с которой мы берем изменения, чтобы влить их в целевую.

**Целевая ветка** – та ветка, в которую мы сливаем наши изменения.

**Слияние веток** – это перенос изменений с одной ветки на другую. При этом слияние не затрагивает сливаемую ветку, то есть она остается в том же состоянии, что позволяет нам потом продолжить работу с ней.

Для того, чтобы выполнить слияние, нам надо сначало перейти на целевую ветку master и выполнить команду **git merge имя_сливаемой_ветки**. 
В процессе слияния может произойти КОНФЛИКТ или слияние может произойти автоматически. 

Конфликты слияния могут пугать. К счастью, Git предлагает мощные инструменты их поиска и разрешения. Большую часть слияний система Git способна обрабатывать самостоятельно с помощью функций автоматического слияния. Конфликт возникает, когда в двух ветках была изменена одна и та же строка в файле или когда некий файл удален в одной ветке и отредактирован в другой. Как правило, конфликты возникают при работе в команде.

**Чаще всего встречается два типа конфликтов слияния - при запуске и во время процесса слияния.**

Выполнение команды слияния прерывается в самом начале, если Git обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд **git stash**, **git checkout**, **git commit** или **git reset**. 

Git прерывает работу во время слияния
Сбой В ПРОЦЕССЕ слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. Git сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. 

## Команды Git, с помощью которых можно разрешить конфликты слияния

* Команда ** git status** часто используется во время работы с Git и помогает идентифицировать конфликтующие во время слияния файлы.

* Команда **git log --merge** - при передаче аргумента --merge для команды git log будет создан журнал со списком конфликтов коммитов между ветками, для которых выполняется слияние.

* Команда ** git diff** помогает найти различия между состояниями репозитория/файлов. Она полезна для выявления и предупреждения конфликтов слияния.

* Команда ** git checkout** может использоваться для отмены изменений в файлах или для изменения веток.

* Команда ** git reset** может использоваться для отмены изменений в рабочем каталоге или в разделе проиндексированных файлов.

* При выполнении команды **git merge --abort** процесс слияния будет прерван, а ветка вернется к состоянию, в котором она находилась до начала слияния.

## Удаление веток
Для того чтобы удалить уже слитую ветку необходимо использовать команду **git branch --d имя_ветки**. Параметр --d означает delete - удалять.
